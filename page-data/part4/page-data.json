{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part4",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"More techniques\",\n  \"nav_order\": 6,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"properties-of-sql\"\n  }, \"Properties of SQL\"), mdx(\"p\", null, \"In SQL there are many same elements as in programming: Types, statements and functions. We have seen many examples of SQL commands, but let's loon into the language a bit deeper.\"), mdx(\"h1\", {\n    \"id\": \"types\"\n  }, \"Types\"), mdx(\"p\", null, \"The types and their properties depend on the database system we are using. Usually there are several options even for integers and strings. In practice though, types \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INTEGER\"), \" for integers and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TEXT\"), \" for strings go a long way.\"), mdx(\"h2\", {\n    \"id\": \"text-vs-varchar\"\n  }, \"TEXT vs. VARCHAR\"), mdx(\"p\", null, \"Traditional SQL type for saving a string is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"VARCHAR\"), \", where we give the maximum length of the string. For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"VARCHAR(100)\"), \" means a string, which can have at most 100 characters.\"), mdx(\"p\", null, \"This is one remainder of the programming from old times: back then the strings were often saved as an array, with a fixed amount of characters. In practice \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TEXT\"), \" is more versatile as we do not have to come up with the maximum amount of characters.\"), mdx(\"h2\", {\n    \"id\": \"date-datetime-time-timestamp\"\n  }, \"DATE, DATETIME, TIME, TIMESTAMP...\"), mdx(\"p\", null, \"Very useful types of data are the types used for saving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DATE\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TIME\"), \". The naming and usage vary from database system to another, so it is best to check the details from the documentation of the databasey system we are using.\"), mdx(\"h1\", {\n    \"id\": \"statements\"\n  }, \"Statements\"), mdx(\"p\", null, \"Statements are a part of SQL command, with a certain value. For example in query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT price FROM Products WHERE name='radish';\\n\")), mdx(\"p\", null, \"Has four statements: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'radish'\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name='radish'\"), \". In this the statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" get their values from the column of the row, statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'radish'\"), \" is a string and the statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name='radish'\"), \" is a conditional statement to limit the query.\"), mdx(\"p\", null, \"We can also use calculations and other operators the same way as in programming. For example the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT price*2 FROM Products WHERE name='radish';\\n\")), mdx(\"p\", null, \"returns the price of the radish doubled.\"), mdx(\"p\", null, \"A good way to test how SQL statements work is to discuss with the database by doing queries which do not search information from any tables, but only calculate values for statements. This could be something like\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> SELECT 2*(1+3);\\n8\\nsqlite> SELECT 'tes' || 'ts';\\ntests\\nsqlite> SELECT 3 < 5;\\n1\\n\")), mdx(\"p\", null, \"The first query calculates the value for statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2*(1+3)\"), \". The second query combines with the operator \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"||\"), \" the strings 'tes' and 'ts'. into 'tests'. Third query defines the truth value for statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3 < 5\"), \". The practice in SQL is that the truth value is given as an integer: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1 is true\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0 is false\"), \".\"), mdx(\"p\", null, \"Many items for SQL statements are already familar from programming:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"calculations: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"+\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"*\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"%\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"comparison: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"=\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<>\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<=\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">=\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"combining conditions: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AND\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"OR\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NOT\"))), mdx(\"p\", null, \"In addition to these SQL has some more special features, whose knowledge is useful. Next we will look into some of them:\"), mdx(\"h2\", {\n    \"id\": \"between\"\n  }, \"BETWEEN\"), mdx(\"p\", null, \"Statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X BETWEEN a AND b\"), \" is true, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"X\"), \" is at least \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and at most \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \". For example the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE price BETWEEN 4 AND 6;\\n\")), mdx(\"p\", null, \"Returns the products, whose price is at least 6 and at maximum 6. We can also write the same query like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE price >= 4 AND price <= 6;\\n\")), mdx(\"h2\", {\n    \"id\": \"case\"\n  }, \"CASE\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CASE\"), \" structure enables conditional statements. It can have one or more \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHEN\"), \" and a possible \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ELSE\"), \". For example the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name, \\n  CASE WHEN price>5 THEN 'expensive' \\n    ELSE 'cheap' \\n  END \\nFROM Products;\\n\")), mdx(\"p\", null, \"Retrieves the name for all the products and the information about them, if they are expensive or cheap. In this query the product is expensive if the price is over 5, otherwise it is cheap.\"), mdx(\"h2\", {\n    \"id\": \"in\"\n  }, \"IN\"), mdx(\"p\", null, \"Statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x IN (...)\"), \" is true, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" is some of the given values. For example the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE name IN ('turnip','cucumber','celery');\\n\")), mdx(\"p\", null, \"Returns the products whose name is turnip, cucumber or celery.\"), mdx(\"h2\", {\n    \"id\": \"like\"\n  }, \"LIKE\"), mdx(\"p\", null, \"Statement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s LIKE p\"), \" is true, if the string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"s\"), \" matches to the description \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p\"), \". In the description we can use special characters \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \" (any single character) and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"%\"), \" (any amount of any characters). For example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE name LIKE '%er%';\\n\")), mdx(\"p\", null, \"Returns the products whose name contain the string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"er\"), \" (such as cucumber and celery).\"), mdx(\"h2\", {\n    \"id\": \"null\"\n  }, \"NULL\"), mdx(\"p\", null, \"Handling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \" values we have a separate syntax. For example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE price IS NULL;\\n\")), mdx(\"p\", null, \"retrieves the products to which no price has been set, and the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE price IS NOT NULL;\\n\")), mdx(\"p\", null, \"retrieves the products to which the price has been set.\"), mdx(\"h2\", {\n    \"id\": \"functions\"\n  }, \"Functions\"), mdx(\"p\", null, \"As a part of statements we can have functions, just like in programming. As with types, the functions available and their usage are dependant on the used database system and additional information should be checked from the database system documentation.\"), mdx(\"p\", null, \"Here are some useful SQLite functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name          function\\n--------      ----------\\nABS(x)        returns the absolute value for x\\nCOALESCE(...) returns the first value from the list, which is not NULL\\nLENGTH(s)     returns the length of the string s\\nLOWER(s)      changes the characters in string s to lower case\\nMAX(x,y)      returns the greater of integers x and y\\nMIN(x,y)      returns the smaller of integers x and y\\nRANDOM()      returns a random number\\nROUND(x,d)    returns x rounded to d decimals\\nUPPER(s)     changers the characters in string s to upper case\\n\")), mdx(\"p\", null, \"For example the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE LENGTH(name)=6;\\n\")), mdx(\"p\", null, \"Returns the products whose name are six characters long (such as carrot, radish, turnip and celery). The query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY RANDOM();\\n\")), mdx(\"p\", null, \"Returns the all the rows in random order, since the order is not based on any column but on a random number.\"), mdx(\"h1\", {\n    \"id\": \"subqueries\"\n  }, \"Subqueries\"), mdx(\"p\", null, \"Subqueries are a statement used as a part of a SQL command, whose value is determined by a query. We can build subqueries in the same manner as main queries and produce queries with them, which could be difficult to achieve otherwise. \"), mdx(\"h2\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"p\", null, \"Let's look at a situation, where the database has a table for players' scores in the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Results\"), \". We assume the table is following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        score     \\n----------  ----------  ----------\\n1           Uolevi      120       \\n2           Maija       80        \\n3           Liisa       120       \\n4           Aapeli      45        \\n5           Kaaleppi    115    \\n\")), mdx(\"p\", null, \"Now we want to know the players who have achieved the top score, and the query should return Uolevi and Liisa. We can achieve this by subquery like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name, score FROM Results \\nWHERE score = (SELECT MAX(score) FROM Results);\\n\")), mdx(\"p\", null, \"And we get:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        score     \\n----------  ----------\\nUolevi      120       \\nLiisa       120       \\n\")), mdx(\"p\", null, \"In this scenario the subquery is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT MAX(score) FROM Results\"), \", which gives the largest score in the table, in this case 120. Notice, that the subquery has to be enclosed brackets, so that it does not mix up with the outer query.\"), mdx(\"p\", null, \"Here's a bit more comlex query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name, score FROM Results \\nWHERE score >= 0.9*(SELECT MAX(score) FROM Results);\\n\")), mdx(\"p\", null, \"This query shows, that we can use the value from the subquery as part of a statement, just like any other value. The query retrieves the players, whose score is at most 10 percent lower than the the best score:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        score     \\n----------  ----------\\nUolevi      120       \\nLiisa       120       \\nKaaleppi    115     \\n\")), mdx(\"h2\", {\n    \"id\": \"correlated-or-synchronized-subquery\"\n  }, \"Correlated or synchronized subquery\"), mdx(\"p\", null, \"A subquery is also possible to create so, that its content is dependant or a row in the outer query. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name, score, \\n  (SELECT COUNT(*) FROM Results WHERE score > R.score) better \\n  FROM Results R;\\n\")), mdx(\"p\", null, \"The idea for this query is to calculate for each player, how many players have a better score than them. For example for Maija the answer is 3, since Uolevi, Liisa and Kaaleppi have better scores. We get the following result set:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        score       better\\n----------  ----------  ----------\\nUolevi      120         0                                                    \\nMaija       80          3                                                    \\nLiisa       120         0                                                    \\nAapeli      45          4                                                    \\nKaaleppi    115         2                                                   \\n\")), mdx(\"p\", null, \"Because the table Results is in two roles in the subquery, we have given the table Results additional name R. With this in the subquery it is clear that we want to count rows, whose score is better than the row score from the outer query.\"), mdx(\"h2\", {\n    \"id\": \"multiple-values-in-subquery\"\n  }, \"Multiple values in subquery\"), mdx(\"p\", null, \"Subquery can also return multiple values, as long as the result from the subquery are used in a location where this is allowed. This works in for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name FROM Products\\nWHERE id IN (SELECT product_id FROM Purchases WHERE customer_id = 1);\\n\")), mdx(\"p\", null, \"This query retrieves all the names for products in customer 1's shopping cart. The subquery returns the id values for the products, which can be combined with the IN syntax.\"), mdx(\"p\", null, \"Notice, that we could have done the query also like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT P.name\\nFROM Products P, Purchases O\\nWHERE P.id = O.product_id AND O.customer_id = 1;\\n\")), mdx(\"p\", null, \"Often a subquery is an alternative way to produce a query, which could just as well be done with for example properly designed multiple table query.\"), mdx(\"h1\", {\n    \"id\": \"limiting-results\"\n  }, \"Limiting results\"), mdx(\"p\", null, \"SQL query by default returns all the rows mathcing its conditions, but we can ask for only a part of the rows when needed. This is useful for example in applications, where we only want to show a part of the results per page.\"), mdx(\"h2\", {\n    \"id\": \"ways-of-limiting\"\n  }, \"Ways of limiting\"), mdx(\"p\", null, \"When we add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIMIT x\"), \" to the end of a query, the query only returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" first rows. For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIMIT 3\"), \" means, that the query only shows the first three rows of the result set.\"), mdx(\"p\", null, \"A more common form is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIMIT x OFFSET y\"), \", which means that we want \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" rows starting from position \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" (with 0 indexing, of course). For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIMIT 3 OFFSET 1\"), \" means that the result set contains second, third and fourth rows.\"), mdx(\"h2\", {\n    \"id\": \"example-1\"\n  }, \"Example\"), mdx(\"p\", null, \"Let's see an example query, which returns the products from cheapest to most expensive:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY price;\\n\")), mdx(\"p\", null, \"We get the following result set:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n3           cucumber    2\\n5           celery      4         \\n2           carrot      5         \\n1           radish      7         \\n4           turnip      8         \\n\")), mdx(\"p\", null, \"We can get the cheapest three as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY price LIMIT 3;\\n\")), mdx(\"p\", null, \"And the result is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n3           cucumber    2         \\n5           celery      4         \\n2           carrot      5      \\n\")), mdx(\"p\", null, \"The next query in turn gets the three cheapest products, starting from the second cheapest:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY price LIMIT 3 OFFSET 1;\\n\")), mdx(\"p\", null, \"And the result is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n5           celery      4         \\n2           carrot      5         \\n1           radish      7      \\n\")), mdx(\"h2\", {\n    \"id\": \"limiting-subquery\"\n  }, \"Limiting subquery\"), mdx(\"p\", null, \"Let's look at a situation, where we want the combined price of the three cheapest products. The following query does not work like we would want:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT SUM(price) FROM Products ORDER BY price LIMIT 3;\\n\")), mdx(\"p\", null, \"This returns the price of all the products in the table:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"SUM(price)\\n----------\\n26\\n\")), mdx(\"p\", null, \"The problem is that the query forms the return set, where only one row containing the value 26 (sum of all products), after which we select the first three rows of the result set (in practice, the only row there is).\"), mdx(\"p\", null, \"We can solve this with a subquery, where we get the three cheapest prices, and calculate the sum of these:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT SUM(price) FROM (SELECT price FROM Products ORDER BY price LIMIT 3);\\n\")), mdx(\"p\", null, \"Now we get the desired result:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"SUM(price)\\n----------\\n11\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#properties-of-sql","title":"Properties of SQL"},{"url":"#types","title":"Types","items":[{"url":"#text-vs-varchar","title":"TEXT vs. VARCHAR"},{"url":"#date-datetime-time-timestamp","title":"DATE, DATETIME, TIME, TIMESTAMP..."}]},{"url":"#statements","title":"Statements","items":[{"url":"#between","title":"BETWEEN"},{"url":"#case","title":"CASE"},{"url":"#in","title":"IN"},{"url":"#like","title":"LIKE"},{"url":"#null","title":"NULL"},{"url":"#functions","title":"Functions"}]},{"url":"#subqueries","title":"Subqueries","items":[{"url":"#example","title":"Example"},{"url":"#correlated-or-synchronized-subquery","title":"Correlated or synchronized subquery"},{"url":"#multiple-values-in-subquery","title":"Multiple values in subquery"}]},{"url":"#limiting-results","title":"Limiting results","items":[{"url":"#ways-of-limiting","title":"Ways of limiting"},{"url":"#example-1","title":"Example"},{"url":"#limiting-subquery","title":"Limiting subquery"}]}]},"frontmatter":{"title":"More techniques"}}},"pageContext":{"id":"fe04ad1e-bd4f-53eb-b456-f3aa7f2f1634"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}