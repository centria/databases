{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SQL Basics\",\n  \"nav_order\": 4,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"basic-commands\"\n  }, \"Basic commands\"), mdx(\"p\", null, \"Next we will familiarize ourselves with the basic SQL commands. With these commands we add, search, change and delete contents from the database. Usually the combination of these commands are known with other names, however. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C\"), \"reate, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"R\"), \"ead, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"U\"), \"pdate and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"D\"), \"elete, or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CRUD\"), \", forms the basic functionality of database usage, especially in documentation.\"), mdx(\"h2\", {\n    \"id\": \"creating-a-table\"\n  }, \"Creating a table\"), mdx(\"p\", null, \"The command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CREATE TABLE\"), \" indeed creates a table, with the desired columns. For example the following command creates the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" with three columns:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\n\")), mdx(\"p\", null, \"We can name the table and the columns the way we want. Common practice (at least for this course) is, that the tables are written with capital first letter and in plural, and columns with small first letter and in singular form.\"), mdx(\"p\", null, \"For each column, along with the name we declare the desired type. In this table the columns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"integers\"), \" (INTEGER) and the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \"is a string (TEXT). The column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" is also the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"primary key\"), \" (PRIMARY KEY) for the table. This means it creates an identification for each row in the table and with it we can easily refer to any row.\"), mdx(\"h2\", {\n    \"id\": \"primary-key\"\n  }, \"Primary key\"), mdx(\"p\", null, \"The primary key can be any column or combination of columns, which is unique to each row. In practice, a common way for a primary key is an id column with integer type.\"), mdx(\"p\", null, \"We usually want the id to have a sequential numbering. This means that when we add rows to the table, the first row gets automatically id value of 1, second gets id value of 2, and so on.\"), mdx(\"p\", null, \"The implementation of this depends on the database management system. For example in SQLite database \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INTEGER PRIMARY KEY\"), \" column automatically gets a sequential numbering.\"), mdx(\"h2\", {\n    \"id\": \"adding-information\"\n  }, \"Adding information\"), mdx(\"p\", null, \"The command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INSERT\"), \" adds a new row into the table. For example the following command adds a row into the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" we just created\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"INSERT INTO Products (name,price) VALUES ('radish',7);\\n\")), mdx(\"p\", null, \"Here we give the values to the columns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" for the row. When we assume the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" to have a sequential numbering, it automatically gets the value 1, when the row in question is the first row for the table. Thus the table now contains the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n1           radish     7         \\n\")), mdx(\"p\", null, \"If we do not give a value to a column, it gets a default value. In a regular column the default value is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \", which means the data does not exist. For example in the following command we do not give a value to the column price:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"INSERT INTO Products (name) VALUES ('radish');\\n\")), mdx(\"p\", null, \"Now the table gets a row, where the price is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \" (or empty):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n1           radish     \\n\")), mdx(\"h2\", {\n    \"id\": \"example-table\"\n  }, \"Example table\"), mdx(\"p\", null, \"In this chapter we assume in our examples, that we have added the following lines into our table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"INSERT INTO Products (name,price) VALUES ('radish',7);\\nINSERT INTO Products (name,price) VALUES ('carrot',5);\\nINSERT INTO Products (name,price) VALUES ('turnip',4);\\nINSERT INTO Products (name,price) VALUES ('cucumber',8);\\nINSERT INTO Products (name,price) VALUES ('celery',4);\\n\")), mdx(\"p\", null, \"Now the table looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n1           radish      7         \\n2           carrot      5         \\n3           turnip      4         \\n4           cucumber    8         \\n5           celery      4       \\n\")), mdx(\"h2\", {\n    \"id\": \"retrieving-information\"\n  }, \"Retrieving information\"), mdx(\"p\", null, \"The command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT\"), \" performs a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"query\"), \", or retrieves information from the table. The simplest way to perform a query is to get all the information from a table:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products;\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n1           radish      7         \\n2           carrot      5         \\n3           turnip      4         \\n4           cucumber    8         \\n5           celery      4       \\n\")), mdx(\"p\", null, \"The asterisk \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" represents all the columns. We can of course get only certain columns instead. For example we can get only the names of the products:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name FROM Products;\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name      \\n----------\\nradish    \\ncarrot             \\nturnip               \\ncucumber               \\ncelery    \\n\")), mdx(\"p\", null, \"This query gets the names and the prices:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name, price FROM Products;\\n\")), mdx(\"p\", null, \"Now the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"name        price     \\n----------  ----------\\nradish      7         \\ncarrot      5         \\nturnip      4         \\ncucumber    8         \\ncelery      4         \\n\")), mdx(\"p\", null, \"As a result of the query the rows form a table, which is called a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"result set\"), \". Its columns and rows are dependand on the content of the query. For example the previous query created a result set with two columns and five rows.\"), mdx(\"p\", null, \"The result set is sort of a table. Thus while handling databases, there are two types of tables: Fixed tables in the database, and temporary tables created by the queries, whose content are fetched from the fixed tables.\"), mdx(\"h2\", {\n    \"id\": \"search-clauses\"\n  }, \"Search clauses\"), mdx(\"p\", null, \"Adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT\"), \" query we can choose only a part of the rows according to our desired condition. For example the following query retrieves the information for cucumber:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE name='cucumber';\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n4           cucumber    8        \\n\")), mdx(\"p\", null, \"We can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AND\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OR\"), \" in the same way as other programming. For example the next query retrieves the products whose price is between 4...6:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products WHERE price>=4 AND price<=6;\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n2           carrot      5         \\n3           turnip      4         \\n5           celery      4         \\n\")), mdx(\"h2\", {\n    \"id\": \"ordering\"\n  }, \"Ordering\"), mdx(\"p\", null, \"As a default the order of the returned rows can be anything. We can determine the desired order with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ORDER BY\"), \" in our query. For example the next query returns the results in alphabetical order by product name:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY name;\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n2           carrot      5\\n5           celery      4\\n4           cucumber    8         \\n1           radish      7\\n3           turnip      4         \\n\")), mdx(\"p\", null, \"The default order is from smallest to largest (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ASC\"), \"ENDING). However we can reverse the order, we can add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DESC\"), \" (for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DESC\"), \"ENDING) after the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY name DESC;\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n3           turnip      4  \\n1           radish      7\\n4           cucumber    8\\n5           celery      4\\n2           carrot      5\\n\")), mdx(\"p\", null, \"If you want to be certain about the ascending order, you can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ASC\"), \" in your query. Thus, the following queries are identical:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY name;\\nSELECT * FROM Products ORDER BY name ASC;\\n\")), mdx(\"p\", null, \"In practice, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ASC\"), \" is not very often used, as it is the default.\"), mdx(\"p\", null, \"We can also order the rows with multiple criteria. For example the following query orders the rows primarily from most expensive to cheapest and secondarily by name:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Products ORDER BY price DESC, name;\\n\")), mdx(\"p\", null, \"In this case the query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n4           cucumber    8         \\n1           radish      7         \\n2           carrot      5         \\n5           celery      4\\n3           turnip      4    \\n\")), mdx(\"p\", null, \"In this case turnip and celery are ordered by their name (ascending), as they have the same price.\"), mdx(\"h2\", {\n    \"id\": \"distinct-result-rows\"\n  }, \"Distinct result rows\"), mdx(\"p\", null, \"Sometimes result sets can have similar rows. This happens for example with the next query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT price FROM Products;\\n\")), mdx(\"p\", null, \"As two products have a price of 4, two result rows have the content of 4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"price     \\n----------\\n7         \\n5         \\n4         \\n8         \\n4  \\n\")), mdx(\"p\", null, \"If we only want different results, we can add the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DISTINCT\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT DISTINCT price FROM Products;\\n\")), mdx(\"p\", null, \"With this the result becomes the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"price     \\n----------\\n7         \\n5         \\n4         \\n8         \\n\")), mdx(\"h2\", {\n    \"id\": \"changing-information\"\n  }, \"Changing information\"), mdx(\"p\", null, \"The command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE\"), \" changes the content of the rows which match the selected condition. For example the next command changes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" for turnip to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"UPDATE Products SET price=6 WHERE name='turnip';\\n\")), mdx(\"p\", null, \"You can change several values by combining the changes with comma. For example the following command sets the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" of the turnip into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pineapple\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"9\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"UPDATE Products SET name='pineapple', price=9 WHERE name='turnip';\\n\")), mdx(\"p\", null, \"The change can also be calculated from a previous value. For example the following command increases the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" of the turnip \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"by 1\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"UPDATE Products SET price=price+1 WHERE name='turnip';\\n\")), mdx(\"p\", null, \"If the command does not have a condition, the update affects all rows. For example the following command changes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" of all the products into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"UPDATE Products SET price=3;\\n\")), mdx(\"h2\", {\n    \"id\": \"removing-information\"\n  }, \"Removing information\"), mdx(\"p\", null, \"The command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DELETE\"), \" removes from the table the rows, which match the wanted condition. For example the following command removes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"carrot\"), \" from products:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"DELETE FROM Products WHERE name='carrot';\\n\")), mdx(\"p\", null, \"Alike in changing, if there are no conditionals, the command affects all rows. The following command removes all the rows from the table:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"DELETE FROM Products;\\n\")), mdx(\"p\", null, \"The command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DROP TABLE\"), \" removes the table (and all its content). For example the following command removes the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"DROP TABLE Products;\\n\")), mdx(\"h1\", {\n    \"id\": \"aggregate-queries\"\n  }, \"Aggregate queries\"), mdx(\"p\", null, \"An aggregate query calculates a single value from the rows of a table. For example we can count the amount of rows or the sum of all the values in a column. We can also group the rows by columns and run an aggregate query for each group.\"), mdx(\"h2\", {\n    \"id\": \"aggregate-functions\"\n  }, \"Aggregate functions\"), mdx(\"p\", null, \"The aggregate queries are based on aggregate functions, which perform operations for the rows or columns. Common aggrecate functions are the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name          function\\n---------     ---------------------------\\nCOUNT()       counts the amount of rows\\nSUM()         counts the sum of rows\\nMIN()         retrieves the smallest value\\nMAX()         retrieves the largest value\\nAVG()         counts the average\\n\")), mdx(\"h2\", {\n    \"id\": \"examples\"\n  }, \"Examples\"), mdx(\"p\", null, \"Let's look at the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" we created earlier:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n1           radish      7         \\n2           carrot      5         \\n3           turnip      4         \\n4           cucumber    8         \\n5           celery      4       \\n\")), mdx(\"p\", null, \"The next query returns the count of rows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT COUNT(*) FROM Products;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"COUNT(*)\\n----------\\n5\\n\")), mdx(\"p\", null, \"The following returns the count of those rows, whose price is 4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT COUNT(*) FROM Products WHERE price=4;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"COUNT(*)\\n----------\\n2\\n\")), mdx(\"p\", null, \"The following query counts the sum of the prices:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT SUM(price) FROM Products;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"SUM(price)\\n----------\\n28\\n\")), mdx(\"h2\", {\n    \"id\": \"selecting-rows\"\n  }, \"Selecting rows\"), mdx(\"p\", null, \"If the aggregate function contains asterisk \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \", the query selects all rows. If the function contains the name of a column, the query will choose the rows whose value \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is not\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \".\"), mdx(\"p\", null, \"Let's look at the following table, whose row 3 has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \" for price:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name        price     \\n----------  ----------  ----------\\n1           radish      7         \\n2           turnip      4         \\n3           cucumber               \\n4           celery      4         \\n\")), mdx(\"p\", null, \"The following query returns the count of rows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT COUNT(*) FROM Products;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"COUNT(*)  \\n----------\\n4\\n\")), mdx(\"p\", null, \"The following query return those rows, whose price is not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT COUNT(price) FROM Products;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"COUNT(price)\\n------------\\n3\\n\")), mdx(\"p\", null, \"We can also use the keyword \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DISTINCT\"), \" in aggregate queries. For example the following query informs us, how many different (not NUll) values for price the table has:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT COUNT(DISTINCT price) FROM Products;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"COUNT(DISTINCT price)\\n---------------------\\n2\\n\")), mdx(\"h2\", {\n    \"id\": \"grouping\"\n  }, \"Grouping\"), mdx(\"p\", null, \"With grouping we can combine information from rows and aggregate functions. The idea behind this is that rows are divided into groups with columns assigned to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GROUP BY\"), \", after which the aggregate function is calculated for each group separately.\"), mdx(\"p\", null, \"Let's have another example of table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sales\"), \", where we have information about sales amounts for different years:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          product       year       amount\\n----------  ----------  ----------  ----------\\n1           radish      2017        120\\n2           radish      2018        85\\n3           radish      2019        150\\n4           turnip      2017        30\\n5           turnip      2018        35\\n6           turnip      2019        10\\n7           cucumber    2017        75\\n8           cucumber    2018        100\\n9           cucumber    2019        80\\n\")), mdx(\"p\", null, \"The next query returns the total sales per year by grouping:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT year, SUM(amount) FROM Sales GROUP BY year;\\n\")), mdx(\"p\", null, \"The query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"year       SUM(amount)\\n----------  ----------\\n2017        225       \\n2018        220       \\n2019        240       \\n\")), mdx(\"p\", null, \"For example the total sales of 2017 is 120 + 30 + 75 = 225.\"), mdx(\"p\", null, \"On the other had, we can get the total sales by product like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT product, SUM(amount) FROM Sales GROUP BY product;\\n\")), mdx(\"p\", null, \"The query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"product       SUM(amount)\\n----------  ----------\\ncucumber    255       \\nturnip      75        \\nradish      355\\n\")), mdx(\"p\", null, \"For example the total sales for cucumber is 75 + 100 + 80 = 255.\"), mdx(\"h2\", {\n    \"id\": \"naming-the-return-column\"\n  }, \"Naming the return column\"), mdx(\"p\", null, \"By default the column in the return set gets its name direclty by the query, but we can name them ourselves with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AS\"), \" keyword. With this we can clarify, what the aggregate query is about.\"), mdx(\"p\", null, \"For example in the following query the name of the second column is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT product, SUM(amount) AS total FROM Sales GROUP BY product;\\n\")), mdx(\"p\", null, \"The query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"product     total\\n----------  --------\\ncucumber    255       \\nturnip      75        \\nradish      355\\n\")), mdx(\"p\", null, \"Actually, the word \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AS\"), \" is not compulsory, so we could write the query also like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT product, SUM(amount) total FROM Sales GROUP BY product;\\n\")), mdx(\"h2\", {\n    \"id\": \"limitation-after-grouping\"\n  }, \"Limitation after grouping\"), mdx(\"p\", null, \"We can add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HAVING\"), \" to our query, which limits the results \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" the grouping. For example the following query returns the products, whose sale is at least 200:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT product, SUM(amount) AS total\\nFROM Sales\\nGROUP BY product\\nHAVING total >= 200;\\n\")), mdx(\"p\", null, \"The query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"product     total\\n----------  --------\\ncucumber    255       \\nradish      355     \\n\")), mdx(\"h2\", {\n    \"id\": \"query-overview\"\n  }, \"Query overview\"), mdx(\"p\", null, \"In our queries we can use many of the clauses we have learnt so far, as long as they are in the following order:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"SELECT \\u2013 FROM \\u2013 WHERE \\u2013 GROUP BY \\u2013 HAVING \\u2013 ORDER BY\\n\")), mdx(\"p\", null, \"Here is an example of a query with all these parts:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT product, SUM(amount) AS total\\nFROM Sales\\nWHERE year < 2019\\nGROUP BY product\\nHAVING total >= 100\\nORDER BY product;\\n\")), mdx(\"p\", null, \"The query returns the sales of the products before the year 2019, only shows products whose sale in these years is over 100, and orders the results by name. The query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"product       total\\n----------  --------\\ncucumber    175       \\nradish      205      \\n\")), mdx(\"p\", null, \"Notice the difference between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HAVING\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" limits the rows \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before\"), \" grouping, whereas \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HAVING\"), \" limits \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"after\"), \" the grouping.\"), mdx(\"h1\", {\n    \"id\": \"sqlite-database\"\n  }, \"SQLite database\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SQLite\"), \" is a simple and openly availabe database system, which is suitable for learning SQL. You can try the basic functions of SQL with SQLite, and we will use it with some of the examples during this course. \"), mdx(\"h2\", {\n    \"id\": \"database-systems\"\n  }, \"Database systems\"), mdx(\"p\", null, \"SQLite is a valid choice for learning SQL, but it does have some restrictions, which can cause problems in actual programs.\"), mdx(\"p\", null, \"Widely used open database systems are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MySQL\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PostgreSQL\"), \". They have a large amount of features which are lacking from SQLite, but on the other hand their installation and often usage is more difficult.\"), mdx(\"p\", null, \"Transferring data from different database systems is quite easy, as they all have similar SQL language.\"), mdx(\"h2\", {\n    \"id\": \"sqlite-interpreter\"\n  }, \"SQLite interpreter\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Interpreter\"), \" is a program, with which we can use a database. In this case, we are using one for SQLite. The interpreter can be run by giving the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sqlite3\"), \" on command line. Now we can write and run SQL commands or commands beginning with a dot for the interpreter.\"), mdx(\"p\", null, \"If the computer you are using does not have the SQLite interpreter, you can install it from here:\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.sqlite.org/download.html\"\n  }, \"https://www.sqlite.org/download.html\")), mdx(\"p\", null, \"Choose the according your operating system a packet, which is marked with the topic \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"command-line tools\"), \". The file you need is the one whose name begins with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sqlite3\"), \".\"), mdx(\"h2\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"p\", null, \"In the SQLite interpreter the database is by default in memory (being then an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"in-memory database\"), \"). This means it is empty in the beginning and disappears when the interpreter is closed. This is a good way to test the properties of SQL. A set of commands with the interpreter coud look something like this (with some additional line breaks for readibility):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ sqlite3\\nSQLite version 3.11.0 2016-02-15 17:29:24\\nEnter \\\".help\\\" for usage hints.\\nConnected to a transient in-memory database.\\nUse \\\".open FILENAME\\\" to reopen on a persistent database.\\n\\nsqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\n\\nsqlite> .tables\\nProducts\\n\\nsqlite> INSERT INTO Products (name,price) VALUES ('radish',7);\\n\\nsqlite> INSERT INTO Products (name,price) VALUES ('carrot',5);\\n\\nsqlite> INSERT INTO Products (name,price) VALUES ('turnip',4);\\n\\nsqlite> INSERT INTO Products (name,price) VALUES ('cucumber',8);\\n\\nsqlite> INSERT INTO Products (name,price) VALUES ('celery',4);\\n\\nsqlite> SELECT * FROM Products;\\n\\n1|radish|7\\n2|carrot|5\\n3|turnip|4\\n4|cucumber|8\\n5|celery|4\\n\\nsqlite> .mode column\\n\\nsqlite> .headers on\\n\\nsqlite> SELECT * FROM Products;\\n\\nid          name        price     \\n----------  ----------  ----------\\n1           radish      7         \\n2           carrot      5         \\n3           turnip      4         \\n4           cucumber    8         \\n5           celery      4         \\n\\nsqlite> .quit\\n\")), mdx(\"p\", null, \"In the example we begin by creating a table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" and then check with the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".tables\"), \", what tables exist in the database. The only table is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \", as it was supposed to.\"), mdx(\"p\", null, \"After this we add rows to the table and retrieve all the rows from the table. The default of SQLite is to separate the columns with vertical lines. We make the results more readable with the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".mode column\"), \" (each column has a fixed width) and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".headers on\"), \" (showing the names of the columns). Finally we run the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".quit\"), \", which closes the SQLite interpreter.\"), mdx(\"h2\", {\n    \"id\": \"database-in-a-file\"\n  }, \"Database in a file\"), mdx(\"p\", null, \"When running the SQLite interpreter, we can give a filename as a parameter, into which the database is saved. Thus the content of the database is saved after the interpreter is closed.\"), mdx(\"p\", null, \"In the following example the database is saved into the file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test.db\"), \". With this the content of the database is still available, when the interpreter is run again.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ sqlite3 test.db\\nSQLite version 3.11.0 2016-02-15 17:29:24\\nEnter \\\".help\\\" for usage hints.\\n\\nsqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\n\\nsqlite> .tables\\nProducts\\n\\nsqlite> .quit\\n\\n$ sqlite3 test.db\\nSQLite version 3.11.0 2016-02-15 17:29:24\\nEnter \\\".help\\\" for usage hints.\\n\\nsqlite> .tables\\nProducts\\n\\nsqlite> .quit\\n\")), mdx(\"h2\", {\n    \"id\": \"commands-from-a-file\"\n  }, \"Commands from a file\"), mdx(\"p\", null, \"For the interpreter we can also redirect a file containing commands, which are run one after another. With this we can automate running the commands. For example we can run the commands from the following file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"commands.sql\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\nINSERT INTO Products (name,price) VALUES ('radish',7);\\nINSERT INTO Products (name,price) VALUES ('carrot',5);\\nINSERT INTO Products (name,price) VALUES ('turnip',4);\\nINSERT INTO Products (name,price) VALUES ('cucumber',8);\\nINSERT INTO Products (name,price) VALUES ('celery',4);\\n.mode column\\n.headers on\\nSELECT * FROM Products;\\n\")), mdx(\"p\", null, \"After this we can redirect the commands from the file to the interpreter as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ sqlite3 < commands.sql\\nid          name        price     \\n----------  ----------  ----------\\n1           radish      7         \\n2           carrot      5         \\n3           turnip      4         \\n4           cucumber    8         \\n5           celery      4 \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#basic-commands","title":"Basic commands","items":[{"url":"#creating-a-table","title":"Creating a table"},{"url":"#primary-key","title":"Primary key"},{"url":"#adding-information","title":"Adding information"},{"url":"#example-table","title":"Example table"},{"url":"#retrieving-information","title":"Retrieving information"},{"url":"#search-clauses","title":"Search clauses"},{"url":"#ordering","title":"Ordering"},{"url":"#distinct-result-rows","title":"Distinct result rows"},{"url":"#changing-information","title":"Changing information"},{"url":"#removing-information","title":"Removing information"}]},{"url":"#aggregate-queries","title":"Aggregate queries","items":[{"url":"#aggregate-functions","title":"Aggregate functions"},{"url":"#examples","title":"Examples"},{"url":"#selecting-rows","title":"Selecting rows"},{"url":"#grouping","title":"Grouping"},{"url":"#naming-the-return-column","title":"Naming the return column"},{"url":"#limitation-after-grouping","title":"Limitation after grouping"},{"url":"#query-overview","title":"Query overview"}]},{"url":"#sqlite-database","title":"SQLite database","items":[{"url":"#database-systems","title":"Database systems"},{"url":"#sqlite-interpreter","title":"SQLite interpreter"},{"url":"#example","title":"Example"},{"url":"#database-in-a-file","title":"Database in a file"},{"url":"#commands-from-a-file","title":"Commands from a file"}]}]},"frontmatter":{"title":"SQL Basics"}}},"pageContext":{"id":"99dbf5e7-fd8e-5491-9f4f-7c581adb1ec4"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}