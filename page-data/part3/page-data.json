{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part3",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Multible tables\",\n  \"nav_order\": 5,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"references-and-queries\"\n  }, \"References and queries\"), mdx(\"p\", null, \"The central idea about relational databases is, that a row in a table can \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rerefence\"), \" to a row in another table. Thus we can form a query, which collects information from several tables, based on the references. In practice the reference is usually made to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" of the other table.\"), mdx(\"h2\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"p\", null, \"Let's examine a situation, where a database has information about coursee and their teachers. We assume, that each course has only one teacher, and one teacher can teach several courses.\"), mdx(\"p\", null, \"We save the information about teachers into the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \". Each teacher has an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \", which we can reference.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name      \\n----------  ----------\\n1           Ahonen     \\n2           Isohanni\\n3           Niemi   \\n4           Laaksonen \\n\")), mdx(\"p\", null, \"In the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" we have the information about the courses and for each course we have a reference to the teacher.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name               teacher_id\\n----------  ----------------   -----------\\n1           Basic programming  3          \\n2           More programming   1          \\n3           Algorithms         1          \\n4           Scrum masters      4          \\n5           Algebra            3        \\n\")), mdx(\"p\", null, \"We can now get the courses with their teacher with the following query, which searches information from both tables \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" at the same time:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT Courses.name, Teachers.name\\nFROM Courses, Teachers\\nWHERE Courses.teacher_id = Teachers.id;\\n\")), mdx(\"p\", null, \"As the query has multiple tables, we declare the tables for the columns. For example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses.name\"), \" refers to the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" for the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \".\"), mdx(\"p\", null, \"The query returns information as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name                name      \\n------------------  ----------\\nBasic programming   Niemi   \\nMore programming    Ahonen     \\nAlgorithms          Ahonen     \\nScrum masters       Laaksonen \\nAlgebra             Niemi \\n\")), mdx(\"h2\", {\n    \"id\": \"what-actually-happened-here\"\n  }, \"What actually happened here?\"), mdx(\"p\", null, \"In the query above, compared to previous queries, we are using multiple tables (FROM Courses, Teachers), but what does it mean in practice?\"), mdx(\"p\", null, \"The basic idea is, that when a query has several tables, the starting point of the query is all the possible combinations of all the rows in all the selected tables. After this we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" to define, which of the combinations are we interested at.\"), mdx(\"p\", null, \"A good way to understand the functionality with multiple tables is to first examine a query, which gets us all the columns and does not have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \". In the example database above the search could be as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Courses, Teachers;\\n\")), mdx(\"p\", null, \"Because we have 5 rows in table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" and 4 rows in table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \", the result set of the query is 5 * 4 = 20 rows. The result set contains all the possible ways to first select a row from table Courses and then a row from table Teachers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name                teacher_id   id          name      \\n----------  ------------------  -----------  ----------  ----------\\n1           Basic programming   3            1           Ahonen     \\n1           Basic programming   3            2           Isohanni\\n1           Basic programming   3            3           Niemi   \\n1           Basic programming   3            4           Laaksonen \\n2           More programming    1            1           Ahonen     \\n2           More programming    1            2           Isohanni\\n2           More programming    1            3           Niemi   \\n2           More programming    1            4           Laaksonen \\n3           Algorithms          1            1           Ahonen     \\n3           Algorithms          1            2           Isohanni\\n3           Algorithms          1            3           Niemi   \\n3           Algorithms          1            4           Laaksonen \\n4           Scrum masters       4            1           Ahonen     \\n4           Scrum masters       4            2           Isohanni\\n4           Scrum masters       4            3           Niemi   \\n4           Scrum masters       4            4           Laaksonen \\n5           Algebra             3            1           Ahonen     \\n5           Algebra             3            2           Isohanni\\n5           Algebra             3            3           Niemi   \\n5           Algebra             3            4           Laaksonen \\n\")), mdx(\"p\", null, \"Most of these result rows are not interesting how ever, as they are not connected to one another in any way. For example the first row of results tells us, that a course called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Basic programming\"), \" exists, and so does a teacher called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Ahonen\"), \". For this we limit our search, so thaat the teacher's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" has to match on both tables:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT * FROM Courses, Teachers\\nWHERE Courses.teacher_id = Teachers.id;\\n\")), mdx(\"p\", null, \"With this change we get a more meaningful result:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name               teacher_id   id          name      \\n----------  ----------------   -----------  ----------  ----------\\n1           Basic programming  3            3           Niemi   \\n2           More programming   1            1           Ahonen     \\n3           Algorithms         1            1           Ahonen     \\n4           Scrum masters      4            4           Laaksonen \\n5           Algebra            3            3           Niemi   \\n\")), mdx(\"p\", null, \"Now we can improve more by telling the columns we are interested in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT Courses.name, Teachers.name\\nFROM Courses, Teachers\\nWHERE Courses.teacher_id = Teachers.id;\\n\")), mdx(\"p\", null, \"And get the same result as earlier:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name                name      \\n------------------  ----------\\nBasic programming   Niemi   \\nMore programming    Ahonen     \\nAlgorithms          Ahonen     \\nScrum masters       Laaksonen \\nAlgebra             Niemi \\n\")), mdx(\"h2\", {\n    \"id\": \"more-conditions-in-a-query\"\n  }, \"More conditions in a query\"), mdx(\"p\", null, \"In a query for multiple tables, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" connects the rows of interest for us, but we can have more conditions with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" just like before. For example we could do the following query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT Courses.name, Teachers.name\\nFROM Courses, Teachers\\nWHERE Courses.teacher_id = Teachers.id AND Teachers.name = 'Niemi';\\n\")), mdx(\"p\", null, \"Now we get all the courses taught by Niemi:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name              name      \\n----------------  ----------\\nBasic programming  Niemi   \\nAlgebra  Niemi \\n\")), mdx(\"h2\", {\n    \"id\": \"short-names-for-tables\"\n  }, \"Short names for tables\"), mdx(\"p\", null, \"We can concentrate our queries by giving the tables alternative shorter names, with which we can reference them in the query. For example the query\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT Courses.name, Teachers.name\\nFROM Courses, Teachers\\nWHERE Courses.teacher_id = Teachers.id;\\n\")), mdx(\"p\", null, \"Can be shortened into:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, T.name\\nFROM Courses AS C, Teachers AS T\\nWHERE C.teacher_id = T.id;\\n\")), mdx(\"p\", null, \"And as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AS\"), \" is not compulsory, we can even do:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, T.name\\nFROM Courses C, Teachers T\\nWHERE C.teacher_id = T.id;\\n\")), mdx(\"h2\", {\n    \"id\": \"repeating-a-table\"\n  }, \"Repeating a table\"), mdx(\"p\", null, \"In a query for multiple tables we can use the same table more than once, as long as they are given different names. For example, the following query returns all the possible combinations for choosing how to pair two teachers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT A.name, B.name FROM Teachers A, Teachers B;\\n\")), mdx(\"p\", null, \"Query returns as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        name      \\n----------  ----------\\nAhonen       Ahonen     \\nAhonen       Isohanni\\nAhonen       Niemi   \\nAhonen       Laaksonen \\nIsohanni     Ahonen     \\nIsohanni     Isohanni\\nIsohanni     Niemi   \\nIsohanni     Laaksonen \\nNiemi        Ahonen     \\nNiemi        Isohanni\\nNiemi        Niemi   \\nNiemi        Laaksonen \\nLaaksonen    Ahonen     \\nLaaksonen    Isohanni\\nLaaksonen    Niemi   \\nLaaksonen    Laaksonen \\n\")), mdx(\"h1\", {\n    \"id\": \"junction-table\"\n  }, \"Junction table\"), mdx(\"p\", null, \"There are usually two types of relations between tables:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"One-to-many\"), \" relation: A row from \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table A\"), \" is connected to a maximum of one row in \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table B\"), \". A row from \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table B\"), \" can be connected to many rows in \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table A\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Many-to-many\"), \" relation: A row from \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table A\"), \" can be connected many rows in \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table B\"), \". A row from \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table B\"), \" can be connected to many rows in \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Table A\"), \". \")), mdx(\"p\", null, \"In the first case we can add a column to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Table A\"), \" which references to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Table B\"), \", as we have previously done. In the second case the situation is more difficult, as a single reference in either table would not be sufficient. The solution is to create a third table, which contains the information about the references.\"), mdx(\"h2\", {\n    \"id\": \"example-1\"\n  }, \"Example\"), mdx(\"p\", null, \"Let's examine a situation, where a webshop has products and customers, and each customer has selected a certain amount of products into their shopping cart. A certain customer can have several products, and also same product can be in several customers' carts.\"), mdx(\"p\", null, \"We will build our database so that it has three tables: Products, Customers and Purchases. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"junction table\"), \" Purchases identicates, which products are in which customer's shopping carts. Each row for it is a representation of a pair \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"customer X's cart contains product Y\\\"\"), \".\"), mdx(\"p\", null, \"We assume our tables to have the following content:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" Products \\n id  name     price\\n --  ------   -----\\n 1   radish   7  \\n 2   carrot   5  \\n 3   turnip   4  \\n 4   parsley  8  \\n 5   celery   4  \\n\\n Customers \\n id  name  \\n --  ------\\n 1   Uolevi\\n 2   Maija\\n 3   Aapeli\\n\\n Purchases \\n customer_id  product_id\\n -----------  ----------\\n 1            2\\n 1            5\\n 2            1\\n 2            4\\n 2            5\\n\")), mdx(\"p\", null, \"Now we can get the customers and products like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, P.name\\nFROM Customers C, Products P, Purchases O\\nWHERE C.id = O.customer_id AND P.id = O.product_id;\\n\")), mdx(\"p\", null, \"The idea of the query is to get from tables `\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Customers\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" the information to match the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Purchases\"), \". To get reasonable results, we connect the tables with two conditions. We get the following result set with our query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        name      \\n----------  ----------\\nUolevi      carrot  \\nUolevi      celery   \\nMaija       radish   \\nMaija       parsley    \\nMaija       celery   \\n\")), mdx(\"p\", null, \"With the same idea we could find out, which products are in the cart for a specific customer. For example, the following query retrieves the purchases for Maija:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT P.name\\nFROM Customers C, Products P, Purchases O\\nWHERE C.id = O.customer_id AND P.id = O.product_id AND C.name = 'Maija';\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name      \\n----------\\nradish   \\nparsley    \\ncelery\\n\")), mdx(\"h2\", {\n    \"id\": \"aggregate-from-tables\"\n  }, \"Aggregate from tables\"), mdx(\"p\", null, \"We can use aggregate functions and groupings for queries with multiple tables as well. For example we can create an aggregate, which shows for each customer how many products they have in their shopping cart, and what is the total price. We can do it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, COUNT(P.id), SUM(P.price)\\nFROM Customers C, Products P, Purchases O\\nWHERE C.id = O.customer_id AND P.id = O.product_id\\nGROUP BY C.id;\\n\")), mdx(\"h2\", {\n    \"id\": \"how-are-we-grouping\"\n  }, \"How are we grouping?\"), mdx(\"p\", null, \"In this query the grouping is done by the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C.id\"), \", but in the query we are searching with the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C.name\"), \". This is reasonable, as the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C.id\"), \" dictates the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C.name\"), \", and the query works fine in SQLite.  \"), mdx(\"p\", null, \"In other databases (such as PostgreSQL) the requirement might be, that the column we are searching as such should also be in the grouping. Then the grouping should be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GROUP BY C.id, C.name\")), mdx(\"p\", null, \"The idea of this query is to group the rows by the customer's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \", when the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"COUNT(P.id)\"), \" gives the amount of products in the customer's cart and the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SUM(P.price)\"), \" gives the total amount for said products. Our result set is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        COUNT(P.id)  SUM(P.price)\\n----------  -----------  ------------\\nUolevi      2            9           \\nMaija       3            19          \\n\")), mdx(\"p\", null, \"This means, that Uolevi's purchases contain 2 products, with combined price of 9. Maija on the other hand has 3 products with the combined price of 19. Everything looks good... Or does it?\"), mdx(\"p\", null, \"The problem with our query is that is is missing our third customer, Aapeli. We have come across a problem, which we shall sort by the end of this part.\"), mdx(\"h2\", {\n    \"id\": \"join-syntax\"\n  }, \"JOIN syntax\"), mdx(\"p\", null, \"So far we have gottern information from tables by selectin our tables with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FROM\"), \", which usually works fine. However, sometimes we need to use the alternative \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JOIN\"), \" syntax. It is useful when the result set seems to be \\\"missing\\\" information. \"), mdx(\"h2\", {\n    \"id\": \"ways-of-query\"\n  }, \"Ways of Query\"), mdx(\"p\", null, \"Next we have two ways of doing the same query, first by the way we already know, and the by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JOIN\"), \" syntax.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT Courses.name, Teachers.name\\nFROM Courses, Teachers\\nWHERE Courses.teacher_id = Teachers.id;\\n\\nSELECT Courses.name, Teachers.name\\nFROM Courses JOIN Teachers ON Courses.teacher_id = Teachers.id;\\n\")), mdx(\"p\", null, \"In the latter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JOIN\"), \" syntax, we use the word \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"JOIN\"), \" between the tables as well as a condition to connect the rows with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ON\"), \". After this we could use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" to add more conditions, just like before.\"), mdx(\"p\", null, \"In this case JOIN syntax is just an alternative way to perform the query and it brings nothing new. Let's see next, how we can expand the syntax so, that it gives us new possibilities in our queries.\"), mdx(\"h2\", {\n    \"id\": \"missing-information-problem\"\n  }, \"Missing information problem\"), mdx(\"p\", null, \"Let's have a look at a situation, where we have the example tables of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \", but one course is missing a teacher:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          name               teacher_id\\n----------  ----------------   -----------\\n1           Basic programming  3          \\n2           More programming   1          \\n3           Algorithms         1          \\n4           Scrum masters                \\n5           Algebra            3        \\n\")), mdx(\"p\", null, \"On row 4 column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"teacher_id\"), \" the value is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \", so if we do either of the queries from before, the row 4 does not match any of the rows for table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \". Because of this the result set does not contain the row for Scrum masters:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name                name      \\n------------------  ----------\\nBasic programming   Niemi   \\nMore programming    Ahonen     \\nAlgorithms          Ahonen     \\nAlgebra             Niemi \\n\")), mdx(\"p\", null, \"Solution to this problem is to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LEFT JOIN\"), \" syntax. This means that if a row from the left table does not connect to any row on the right table, the row is still included in the result set. For that row the values based on the right table is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \".\"), mdx(\"p\", null, \"In our case we could do the query like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT Courses.name, Teachers.name\\nFROM Courses LEFT JOIN Teachers ON Courses.teacher_id = Teachers.id;\\n\")), mdx(\"p\", null, \"Now we get the course Scrum masters without a teacher:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name                name      \\n------------------  ----------\\nBasic programming   Niemi   \\nMore programming    Ahonen     \\nAlgorithms          Ahonen     \\nScrum masters       \\nAlgebra             Niemi \\n\")), mdx(\"h2\", {\n    \"id\": \"join-query-family\"\n  }, \"JOIN query family\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JOIN query\"), \" has four variations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JOIN\"), \": Works just as a regular query joining two tables.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"LEFT JOIN\"), \": If the row from the left table does not connect to the right table, it is still chosen to be part of the result set.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RIGHT JOIN\"), \": If the row from the right table does not connect to the left table, it is still chosen to be part of the result set.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FULL JOIN\"), \": From both left and right table we separately add into the result set those rows, which do not connect to the other table.\")), mdx(\"p\", null, \"For SQLite we can only do the first two ones. Fortunately, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LEFT JOIN\"), \" is the most common one (at least on this course, anyways).\"), mdx(\"p\", null, \"A Venn diagram representation would be something like this:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://raw.githubusercontent.com/centria/databases/master/src/images/sql_venn.png\",\n    \"alt\": \"Venn diagram for SQL joins\"\n  }), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.codeproject.com/articles/33052/visual-representation-of-sql-joins\"\n  }, \"Source: C.L.Moffatt\")), mdx(\"p\", null, \"This diagram contains more than four variations. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INNER JOIN\"), \" is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JOIN\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FULL OUTER JOIN\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FULL JOIN\"), \". The other variations are exclusive alternatives for the queries.\"), mdx(\"h2\", {\n    \"id\": \"missing-information-in-aggregate-query\"\n  }, \"Missing information in aggregate query\"), mdx(\"p\", null, \"Now we can tackle the problem of missing Aapeli. In our database we have the following tables:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \" Products \\n id  name     price\\n --  ------   -----\\n 1   radish   7  \\n 2   carrot   5  \\n 3   turnip   4  \\n 4   parsley  8  \\n 5   celery   4  \\n\\n Customers \\n id  name  \\n --  ------\\n 1   Uolevi\\n 2   Maija\\n 3   Aapeli\\n\\n Purchases \\n customer_id  product_id\\n -----------  ----------\\n 1            2\\n 1            5\\n 2            1\\n 2            4\\n 2            5\\n\")), mdx(\"p\", null, \"We declared our aggregate of purchases with the following query:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, COUNT(P.id), SUM(P.price)\\nFROM Customers C, Products P, Purchases O\\nWHERE C.id = O.customer_id AND P.id = O.product_id\\nGROUP BY C.id;\\n\")), mdx(\"p\", null, \"We ended up missing Aapeli from our result set:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        COUNT(P.id)  SUM(P.price)\\n----------  -----------  ------------\\nUolevi      2            9\\nMaija       3            19\\n\")), mdx(\"p\", null, \"The cause for our problem is that Aapeli does not have any purchases, so when the query selects combinations from rows, there are no such rows where Aapeli would be present. The solution is to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LEFT JOIN\"), \" like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, COUNT(P.id), SUM(P.price)\\nFROM Customers C LEFT JOIN Purchases O \\n    ON C.id = O.customer_id\\nLEFT JOIN Products P \\n    ON P.id = O.product_id\\nGROUP BY C.id;\\n\")), mdx(\"p\", null, \"Now we also get Aapeli into our results:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"name        COUNT(P.id)  SUM(P.price)\\n----------  -----------  ------------\\nUolevi      2            9           \\nMaija       3            19          \\nAapeli      0                     \\n\")), mdx(\"p\", null, \"As Aapeli has no purchases, the sum of the prices is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#references-and-queries","title":"References and queries","items":[{"url":"#example","title":"Example"},{"url":"#what-actually-happened-here","title":"What actually happened here?"},{"url":"#more-conditions-in-a-query","title":"More conditions in a query"},{"url":"#short-names-for-tables","title":"Short names for tables"},{"url":"#repeating-a-table","title":"Repeating a table"}]},{"url":"#junction-table","title":"Junction table","items":[{"url":"#example-1","title":"Example"},{"url":"#aggregate-from-tables","title":"Aggregate from tables"},{"url":"#how-are-we-grouping","title":"How are we grouping?"},{"url":"#join-syntax","title":"JOIN syntax"},{"url":"#ways-of-query","title":"Ways of Query"},{"url":"#missing-information-problem","title":"Missing information problem"},{"url":"#join-query-family","title":"JOIN query family"},{"url":"#missing-information-in-aggregate-query","title":"Missing information in aggregate query"}]}]},"frontmatter":{"title":"Multible tables"}}},"pageContext":{"id":"e5d52c68-9463-5278-9ff3-828f84320f1a"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}