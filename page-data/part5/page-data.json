{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/part5",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Designing databases\",\n  \"nav_order\": 7,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"design-principles\"\n  }, \"Design principles\"), mdx(\"p\", null, \"When designing a database we have to decide, which tables the database has and which columns each table has. To do this there are multiple possibilities, but by knowing a few principles and with common sense you can get surprisingly far.\"), mdx(\"p\", null, \"A good goal for designing is that the resulting database is comfortable to use with SQL. The database structure should be such, that we can read and update data easily with SQL commands.\"), mdx(\"p\", null, \"Here are four principles for desiging a database:\"), mdx(\"h2\", {\n    \"id\": \"principle-1\"\n  }, \"Principle 1\"), mdx(\"p\", null, \"The tables and their columns in the database are fixed, and the database user only makes changes to the rows. All the rows containing similar data are in the same table.\"), mdx(\"h2\", {\n    \"id\": \"principle-2\"\n  }, \"Principle 2\"), mdx(\"p\", null, \"Each column contains a singular data, such as an integer or a string, but not a list of information. A list is saved into its own table so that each element is a row of its own.\"), mdx(\"h2\", {\n    \"id\": \"principle-3\"\n  }, \"Principle 3\"), mdx(\"p\", null, \"Each information is exactly once in the database. Elsewhere the information is a referenced by the primary key.\"), mdx(\"h2\", {\n    \"id\": \"principle-4\"\n  }, \"Principle 4\"), mdx(\"p\", null, \"The database does not contain information, which can be calculated or deducted from other information content in the database.\"), mdx(\"h2\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"p\", null, \"Let's look at a situation, where a web site has users and each user has a list of friends. Here we can see quite poorly designed table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Users\"), \", which contains information about users and their friends:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          username    friends       total\\n----------  ----------  ------------  ----------\\n1           uolevi      maija,liisa   2\\n2           maija       aapeli        1\\n3           liisa                     0\\n4           aapeli      uolevi,maija  2\\n\")), mdx(\"p\", null, \"In this table the idea is, that the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"friends\"), \" contains a list of friends as a string, where the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usernames\"), \" for friends are separated with a comma. Also, in the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \" we are given the amount of friends in total a user has.\"), mdx(\"p\", null, \"With this structure we are breaking the principles 2-4, but now we have a chance to evolve the database and think, what the principles are based on.\"), mdx(\"h2\", {\n    \"id\": \"improvement-1\"\n  }, \"Improvement 1\"), mdx(\"p\", null, \"The database breaks the principle 2, since the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"friends\"), \" has a list of friends. The problem with this kind of column is, that it is hard to handle with SQL commands. For example how can we find out, who all have added Maija as their friend?\"), mdx(\"p\", null, \"The solution is to remove the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"friends\"), \" and rather create a new table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Friends\"), \", where each row is a friendship in the form of \\\"user x has user y on their friend list\\\":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"user        friend\\n----------  ----------\\nuolevi      maija\\nuolevi      liisa\\nmaija       aapeli\\naapeli      uolevi\\naapeli      maija\\n\")), mdx(\"p\", null, \"Now the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Users\"), \" looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          username      total\\n----------  ----------  ----------\\n1           uolevi      2\\n2           maija       1\\n3           liisa       0\\n4           aapeli      2\\n\")), mdx(\"p\", null, \"Now we can easily solve, on whose lists Maija is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT user FROM Friends WHERE friend='maija';\\n\")), mdx(\"h2\", {\n    \"id\": \"improvement-2\"\n  }, \"Improvement 2\"), mdx(\"p\", null, \"The new table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Friends\"), \" is nice, but it breaks the principle 3, as the usernames are now in multiple places. The problem here is, that if the username changes, we have to search all the places where the username is used.\"), mdx(\"p\", null, \"The resolution is to change the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Friends\"), \" so that it uses references. Now the table looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"user_id      friend_id\\n-----------  ----------\\n1            2\\n1            3\\n2            4\\n4            1\\n4            2\\n\")), mdx(\"p\", null, \"Notice, this makes it more difficult to find on whose lists Maija is, as we have to get the usernames from table Users:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT A.username\\nFROM Users A, Users B, Friends K\\nWHERE A.id = K.user_id AND B.id = K.friend_id AND B.username = 'maija';\\n\")), mdx(\"p\", null, \"Despite this the change is reasonable, as now the usernames are only used once, in the table Users.\"), mdx(\"h2\", {\n    \"id\": \"improvement-3\"\n  }, \"Improvement 3\"), mdx(\"p\", null, \"The database is still breaking the principle 4, as the column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"total\"), \" can be calculated from the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Friends\"), \". It is quite a handy column, as we can get for example Uolevi's friends like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT total FROM Users WHERE username='uolevi';\\n\")), mdx(\"p\", null, \"The problem is though, that every time we change friends, we would have to update the column total. A better solution is to remove the column from the table:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id          username    \\n----------  ----------\\n1           uolevi    \\n2           maija     \\n3           liisa     \\n4           aapeli    \\n\")), mdx(\"p\", null, \"Even though the column does not exist anymore, we can still count the amount of friends like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT COUNT(*)\\nFROM Users A, Friends K\\nWHERE A.username='uolevi' AND k.user = A.id;\\n\")), mdx(\"h1\", {\n    \"id\": \"normalisation\"\n  }, \"Normalisation\"), mdx(\"p\", null, \"In the theory of database is often used the term \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"normalization\"), \", which is used to make the structure of a database better. This is done by altering the database in such a way, that it implements certain \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"normal forms\"), \".\"), mdx(\"p\", null, \"In practice, normalization leads to the same result as the principles above, but the requirements for normal forms are a bit vague. If you want to spend some time with database theory, you might delve deeper into normal forms. Otherwise the principles above are quite sufficient.\"), mdx(\"h1\", {\n    \"id\": \"depicting-structure\"\n  }, \"Depicting structure\"), mdx(\"p\", null, \"Next we shall handle two ways to depict database structure. A graphical database diagram shows the database tables, columns and the references between them, whereas SQL schema shows the SQL commands used to create the tables.\"), mdx(\"h2\", {\n    \"id\": \"database-diagram\"\n  }, \"Database diagram\"), mdx(\"p\", null, \"A database diagram is a graphical representation of a database, where every table is a box containing the name of the table and the columns as a list. The refences between the rows are shown as connections between the boxes.\"), mdx(\"p\", null, \"There are several tools to draw database diagrams. This picture was done with an online tool \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://dbdiagram.io/d\"\n  }, \"https://dbdiagram.io/\"), \":\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://raw.githubusercontent.com/centria/databases/master/src/images/diagram_new.png\",\n    \"alt\": \"Database diagram of a simple three table Database\"\n  }), \" \"), mdx(\"p\", null, \"Here the notation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" means that the columns has a different value for each row, and the notation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" means that the column can have the same value on multiple rows. For example in the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" each row has different \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \", but in the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Purchases\"), \" multiple rows can have the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"product_id\"), \".\"), mdx(\"h2\", {\n    \"id\": \"sql-schema\"\n  }, \"SQL schema\"), mdx(\"p\", null, \"A SQL Schema is a text representation of the database, where we give the commands needed to create the database. The advantage of this form is that it is definately accurate, and we can recreate the database with it if wanted.\"), mdx(\"p\", null, \"For example the schema for the database above would be as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\nCREATE TABLE Customers (id INTEGER PRIMARY KEY, name TEXT);\\nCREATE TABLE Purchases (product_id INTEGER, customer_id INTEGER);\\n\")), mdx(\"p\", null, \"If we assume this schema to be in a file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"depiction.sql\"), \". we can create the database with the SQLite interpreter with the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".read\"), \": \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> .read depiction.sql\\nsqlite> .tables\\nCustomers  Purchases   Products\\n\")), mdx(\"p\", null, \"On the other hand we can also use the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".schema\"), \" in the SQLite interpreter, which returns the current schema:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> .schema\\nCREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\nCREATE TABLE Customers (id INTEGER PRIMARY KEY, name TEXT);\\nCREATE TABLE Purchases (product_id INTEGER, customer_id INTEGER);\\n\")), mdx(\"h1\", {\n    \"id\": \"changing-database\"\n  }, \"Changing database\"), mdx(\"p\", null, \"In practice it is unusual that the database is designed first and then it stays unchanged until the end of times. It is much more common for the database structure to change every now and then.\"), mdx(\"h2\", {\n    \"id\": \"performing-the-changes\"\n  }, \"Performing the changes\"), mdx(\"p\", null, \"A simple alteration is adding a new table to the database. In this case we can create the table with the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CREATE TABLE\"), \" as usual.\"), mdx(\"p\", null, \"We can also change structure of an existing table with the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ALTER TABLE\"), \". This command has multiple uses, depending on what we want to do. For example we can add a column to the table with the command \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ADD COLUMN\"), \".\"), mdx(\"p\", null, \"Let's look at the table \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Customers\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id           name\\n-----------  ----------\\n1            Uolevi\\n2            Maija\\n3            Aapeli\\n\")), mdx(\"p\", null, \"When we want to add a new column \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"address\"), \", we can run the following command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"ALTER TABLE Customers ADD COLUMN address TEXT;\\n\")), mdx(\"p\", null, \"This results with our table looking like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"id           name        address\\n-----------  ----------  ----------\\n1            Uolevi\\n2            Maija\\n3            Aapeli\\n\")), mdx(\"p\", null, \"Since we added a new column, existing rows do not contain any information in that column. The data can be changed after this with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE\"), \" command.\"), mdx(\"p\", null, \"The usage of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ALTER TABLE\"), \" depends on the database system, and once again more information can be found from the database system documentation. In SQLite the command is quite limited, compared to for example PostgreSQL.\"), mdx(\"h2\", {\n    \"id\": \"challenges-in-alterations\"\n  }, \"Challenges in alterations\"), mdx(\"p\", null, \"Changing the structure of an existing database has one problem: The database usually has information and it is being used in some application. How can we implement the changes so, that they do not interfere the functionality of the system?\"), mdx(\"p\", null, \"Adding a table or a column are usually quite easy changes, since they do not affect using the database in the old way, but more difficult changes are for example removing or changing the name of a column.\"), mdx(\"p\", null, \"One good principle is to do changes gradually, or step by step. For example, if you have to change the name of a column, you can do it like this:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add a new column alongside the old column\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Change the SQL commands \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"writing\"), \" the data so, that they save the data to both old and new column.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Copy the data from the rows of the old column to the new one.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Change the SQL commands \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"reading\"), \" the data so, that they read from the new column.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Change the SQL commands \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"writing\"), \" the data so, that they save the data to only the new column.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Remove the old column from the table.\")), mdx(\"p\", null, \"With this procedure the system can use the database the whole time, and the system user does not notice the change. At the end of the process the name of the column has been changed to a new one.\"), mdx(\"h1\", {\n    \"id\": \"migration\"\n  }, \"Migration\"), mdx(\"p\", null, \"The term \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"migration\"), \" can mean either changing the structure of a database or moving the database information to another location. This is beyond the scope of this course, unfortunately.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#design-principles","title":"Design principles","items":[{"url":"#principle-1","title":"Principle 1"},{"url":"#principle-2","title":"Principle 2"},{"url":"#principle-3","title":"Principle 3"},{"url":"#principle-4","title":"Principle 4"},{"url":"#example","title":"Example"},{"url":"#improvement-1","title":"Improvement 1"},{"url":"#improvement-2","title":"Improvement 2"},{"url":"#improvement-3","title":"Improvement 3"}]},{"url":"#normalisation","title":"Normalisation"},{"url":"#depicting-structure","title":"Depicting structure","items":[{"url":"#database-diagram","title":"Database diagram"},{"url":"#sql-schema","title":"SQL schema"}]},{"url":"#changing-database","title":"Changing database","items":[{"url":"#performing-the-changes","title":"Performing the changes"},{"url":"#challenges-in-alterations","title":"Challenges in alterations"}]},{"url":"#migration","title":"Migration"}]},"frontmatter":{"title":"Designing databases"}}},"pageContext":{"id":"daeaa912-0494-57d6-9080-47bf462b1ede"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}